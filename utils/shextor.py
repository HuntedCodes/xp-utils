#!/usr/bin/python

# Extract shellcode from an executable. Generates C test harness if desires.
# This is useful for getting syscall code in ASM from small compiled C code.
#
# Requires objdump.

from datetime import datetime
from hashlib import sha1, md5
from os.path import isfile
from subprocess import check_output
import re
import sys


def usage():
    print("Description:\n\tExtract shellcode from an executable.\n\t"
          "Option to generate a C test harness.\n"
          "Usage:\n\t"
          "%s <exe file> [<C skeleton file>]\n"
          % sys.argv[0])


def disassemble(file):
    if isfile(file):
        return check_output(['objdump', '-M intel', '-d', file]).split('\n')
    return None


def parse_format(dump, exe_name):
    for line in dump:
        if exe_name in line and 'format' in line:
            format = line.split()
            return format[len(format)-1]


def convert_bytes(hex_string):
    return '\\x'+hex_string.replace(' ', '\\x')


def count_sc_bytes(sc_string):
    bytes = sc_string.replace('\\x', '')
    return len(bytes)/2


def parse_dump(dump):
    expanded_form = ""
    compact_form = ""

    re_exp = "^([a-fA-F0-9]{4,8}) <.+>:$"
    label_re = re.compile(re_exp)

    re_exp = "^ ([a-fA-F0-9]{4,8}:)(\s+)([a-fA-F0-9]{2} ){1,10}.*"
    instruction_re = re.compile(re_exp)

    for line in dump:

        label_match = label_re.match(line)
        instruction_match = instruction_re.match(line)

        if label_match:
            label = label_match.group(0).strip().split()[1]
            label = label[1:len(label)-2]+':'
            expanded_form += '    {0: <32} // {1}\n'.format('', label)

        if instruction_match:
            instruction = instruction_match.group(0).strip().split('\t')
            instruction[1] = instruction[1].strip()

            op_bytes = convert_bytes(instruction[1])
            expanded_form += '    {0: <32} //   {1}\n'.format(
                '"'+op_bytes+'"', instruction[2]
            )
            compact_form += op_bytes

    return (expanded_form, compact_form)


def hash_file(file_name, algo='sha1'):
    block_size = 65536
    h = sha1()
    if algo == 'md5':
        h = md5()

    with open(file_name, 'rb') as f:
        f_buff = f.read(block_size)
        while len(f_buff) > 0:
            h.update(f_buff)
            f_buff = f.read(block_size)
            f.close()
            return h.hexdigest()


def format_header(exe_name, skelly_name, length):
    time = str(datetime.now()).split('.')[0]
    file_format = parse_format(dump, exe_name)
    sha1_hash = hash_file(exe_name, 'sha1')
    md5_hash = hash_file(exe_name, 'md5')
    compile_cmd = ('gcc -fno-stack-protector -z execstack -o %s %s'
                   % (skelly_name.replace('.c', ''), skelly_name))
    compile32_cmd = compile_cmd.replace('gcc', 'gcc -m32')

    return ('/* Generated by shextor\n'
            ' *\n'
            ' * %s - shellcode harness\n'
            ' *\n'
            ' * SC Length: %d bytes\n'
            ' *\n'
            ' * Time:      %s\n'
            ' * Execuable: %s\n'
            ' * Format:    %s\n'
            ' * SHA1:      %s\n'
            ' * MD5:       %s\n'
            ' *\n'
            ' * To disable compile-time stack protections:\n'
            ' *     %s\n'
            ' * To force 32-bit compilation:\n'
            ' *     %s\n'
            ' */\n'
            % (skelly_name, length, time,
               exe_name, file_format,
               sha1_hash, md5_hash,
               compile_cmd, compile32_cmd,))


def format_compact_sc(compact_form):
    return re.sub('([x\\a-fA-F0-9]{4,48})',
                  '    "\\1"\n', compact_form,
                  0, re.DOTALL)


def generate_main():
    return ('\nint main()\n'
            '{\n'
            '    int (*func)();\n'
            '    func = (int (*)()) sc_compact;\n'
            '    (int)(*func)();\n'
            '}\n')


def generate_skeleton(dump, exe_name, skelly_name):

    (expanded, compact_raw) = parse_dump(dump)
    compact = format_compact_sc(compact_raw)
    sc_length = count_sc_bytes(compact_raw)

    skelly = ""
    skelly += format_header(exe_name, skelly_name, sc_length)
    skelly += '\nchar sc_expanded[] =\n'
    skelly += expanded+';'
    skelly += '\nchar sc_compact[] =\n'
    skelly += compact+';'
    skelly += generate_main()

    f = open(skelly_name, 'w')
    f.write(skelly)
    f.close()


if __name__ == "__main__":
    print("shextor - shellcode extractor "
          "by Jack Sullivan <jack@hunted.codes>\n")

    if len(sys.argv) < 2:
        usage()
        sys.exit()

    exe_name = sys.argv[1]

    dump = disassemble(exe_name)
    if not dump:
        print("[*] ERROR: unable to dump executable.")
        sys.exit()

    if len(sys.argv) > 2:
        skelly_name = sys.argv[2]
        generate_skeleton(dump, exe_name, skelly_name)
    else:
        (expanded, compact_raw) = parse_dump(dump)
        compact = format_compact_sc(compact_raw)
        sc_length = count_sc_bytes(compact_raw)
        print('[*] ------ Shellcode Start ------\n'
              '\n%s\n'
              '[*] ------ Shellcode End ------\n'
              '[*] Length: %d bytes'
              % (compact, sc_length))
